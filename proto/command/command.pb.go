// Code generated by protoc-gen-go. DO NOT EDIT.
// source: command/command.proto

package command

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	api "go.chromium.org/goma/server/proto/api"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type CmdDescriptor_PathType int32

const (
	CmdDescriptor_UNKNOWN_PATH_TYPE CmdDescriptor_PathType = 0
	CmdDescriptor_POSIX             CmdDescriptor_PathType = 1
	CmdDescriptor_WINDOWS           CmdDescriptor_PathType = 2
)

var CmdDescriptor_PathType_name = map[int32]string{
	0: "UNKNOWN_PATH_TYPE",
	1: "POSIX",
	2: "WINDOWS",
}

var CmdDescriptor_PathType_value = map[string]int32{
	"UNKNOWN_PATH_TYPE": 0,
	"POSIX":             1,
	"WINDOWS":           2,
}

func (x CmdDescriptor_PathType) String() string {
	return proto.EnumName(CmdDescriptor_PathType_name, int32(x))
}

func (CmdDescriptor_PathType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ce77433d29a243f3, []int{4, 0}
}

// Selector is a command selector.
// it is used to select a compiler or a subprogram/plugin to run on
// cmd_server by matching it with CommandSpec or SubprogramSpec in a request
// from goma client.
// a subprogram/plugin use name and binary_hash for matching.
// basename of path in SubprogramSpec should match with name in Selector.
// TODO: consider also using target.
type Selector struct {
	// command name.
	// name is command base name without version number and architecture.
	// i.e. it should be equivalent CompilerFlags::GetCompilerName.
	// e.g. "gcc", "g++", "clang", "libFindBadConstructs.so",
	// "libFindBadConstructs.dylib".
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// version. e.g. "4.4.3[Ubuntu 4.4.3-4ubuntu5]"
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// compiler's target machine. e.g. gcc -dumpmachine.
	Target string `protobuf:"bytes,3,opt,name=target,proto3" json:"target,omitempty"`
	// binary hash of the command (sha256, hexencoded)
	BinaryHash           string   `protobuf:"bytes,4,opt,name=binary_hash,json=binaryHash,proto3" json:"binary_hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Selector) Reset()         { *m = Selector{} }
func (m *Selector) String() string { return proto.CompactTextString(m) }
func (*Selector) ProtoMessage()    {}
func (*Selector) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce77433d29a243f3, []int{0}
}

func (m *Selector) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Selector.Unmarshal(m, b)
}
func (m *Selector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Selector.Marshal(b, m, deterministic)
}
func (m *Selector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Selector.Merge(m, src)
}
func (m *Selector) XXX_Size() int {
	return xxx_messageInfo_Selector.Size(m)
}
func (m *Selector) XXX_DiscardUnknown() {
	xxx_messageInfo_Selector.DiscardUnknown(m)
}

var xxx_messageInfo_Selector proto.InternalMessageInfo

func (m *Selector) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Selector) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Selector) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *Selector) GetBinaryHash() string {
	if m != nil {
		return m.BinaryHash
	}
	return ""
}

// FileSpec is a file metadata. content is identified by hash.
// NEXT_ID_TO_USE: 9
type FileSpec struct {
	// path in client file system.
	// may be relative.
	// for cmd descriptor, it is relative to command binary directory.
	// (e.g. /usr/bin for /usr/bin/gcc).
	// for CmdReq, it is relative to working directory specified in cmd.Dir.
	Path         string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Size         int64  `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	Hash         string `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
	IsExecutable bool   `protobuf:"varint,4,opt,name=is_executable,json=isExecutable,proto3" json:"is_executable,omitempty"`
	Symlink      string `protobuf:"bytes,5,opt,name=symlink,proto3" json:"symlink,omitempty"`
	// used for goma api.
	HashKey              string        `protobuf:"bytes,6,opt,name=hash_key,json=hashKey,proto3" json:"hash_key,omitempty"`
	Blob                 *api.FileBlob `protobuf:"bytes,7,opt,name=blob,proto3" json:"blob,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *FileSpec) Reset()         { *m = FileSpec{} }
func (m *FileSpec) String() string { return proto.CompactTextString(m) }
func (*FileSpec) ProtoMessage()    {}
func (*FileSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce77433d29a243f3, []int{1}
}

func (m *FileSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileSpec.Unmarshal(m, b)
}
func (m *FileSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileSpec.Marshal(b, m, deterministic)
}
func (m *FileSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileSpec.Merge(m, src)
}
func (m *FileSpec) XXX_Size() int {
	return xxx_messageInfo_FileSpec.Size(m)
}
func (m *FileSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_FileSpec.DiscardUnknown(m)
}

var xxx_messageInfo_FileSpec proto.InternalMessageInfo

func (m *FileSpec) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *FileSpec) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *FileSpec) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *FileSpec) GetIsExecutable() bool {
	if m != nil {
		return m.IsExecutable
	}
	return false
}

func (m *FileSpec) GetSymlink() string {
	if m != nil {
		return m.Symlink
	}
	return ""
}

func (m *FileSpec) GetHashKey() string {
	if m != nil {
		return m.HashKey
	}
	return ""
}

func (m *FileSpec) GetBlob() *api.FileBlob {
	if m != nil {
		return m.Blob
	}
	return nil
}

// Target is a target address.
type Target struct {
	Addr                 string   `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Target) Reset()         { *m = Target{} }
func (m *Target) String() string { return proto.CompactTextString(m) }
func (*Target) ProtoMessage()    {}
func (*Target) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce77433d29a243f3, []int{2}
}

func (m *Target) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Target.Unmarshal(m, b)
}
func (m *Target) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Target.Marshal(b, m, deterministic)
}
func (m *Target) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Target.Merge(m, src)
}
func (m *Target) XXX_Size() int {
	return xxx_messageInfo_Target.Size(m)
}
func (m *Target) XXX_DiscardUnknown() {
	xxx_messageInfo_Target.DiscardUnknown(m)
}

var xxx_messageInfo_Target proto.InternalMessageInfo

func (m *Target) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

// BuildInfo is image build info.
type BuildInfo struct {
	// who build this toolchain.
	Creator string `protobuf:"bytes,2,opt,name=creator,proto3" json:"creator,omitempty"`
	// hostname where the toolchain was built.
	Hostname string `protobuf:"bytes,3,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// current working directory of toolchain build.
	Directory string `protobuf:"bytes,4,opt,name=directory,proto3" json:"directory,omitempty"`
	// when this toolchain was built.
	Timestamp *timestamp.Timestamp `protobuf:"bytes,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// full image name of cmd_server container.
	CmdServer string `protobuf:"bytes,7,opt,name=cmd_server,json=cmdServer,proto3" json:"cmd_server,omitempty"`
	// full qualified toolchain name (separated by space)
	Toolchain            string   `protobuf:"bytes,8,opt,name=toolchain,proto3" json:"toolchain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BuildInfo) Reset()         { *m = BuildInfo{} }
func (m *BuildInfo) String() string { return proto.CompactTextString(m) }
func (*BuildInfo) ProtoMessage()    {}
func (*BuildInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce77433d29a243f3, []int{3}
}

func (m *BuildInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BuildInfo.Unmarshal(m, b)
}
func (m *BuildInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BuildInfo.Marshal(b, m, deterministic)
}
func (m *BuildInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildInfo.Merge(m, src)
}
func (m *BuildInfo) XXX_Size() int {
	return xxx_messageInfo_BuildInfo.Size(m)
}
func (m *BuildInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BuildInfo proto.InternalMessageInfo

func (m *BuildInfo) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *BuildInfo) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *BuildInfo) GetDirectory() string {
	if m != nil {
		return m.Directory
	}
	return ""
}

func (m *BuildInfo) GetTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *BuildInfo) GetCmdServer() string {
	if m != nil {
		return m.CmdServer
	}
	return ""
}

func (m *BuildInfo) GetToolchain() string {
	if m != nil {
		return m.Toolchain
	}
	return ""
}

// CmdDescriptor is a command descriptor.
// NEXT ID TO USE: 7
type CmdDescriptor struct {
	Selector             *Selector                    `protobuf:"bytes,1,opt,name=selector,proto3" json:"selector,omitempty"`
	Setup                *CmdDescriptor_Setup         `protobuf:"bytes,2,opt,name=setup,proto3" json:"setup,omitempty"`
	Cross                *CmdDescriptor_Cross         `protobuf:"bytes,3,opt,name=cross,proto3" json:"cross,omitempty"`
	EmulationOpts        *CmdDescriptor_EmulationOpts `protobuf:"bytes,6,opt,name=emulation_opts,json=emulationOpts,proto3" json:"emulation_opts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *CmdDescriptor) Reset()         { *m = CmdDescriptor{} }
func (m *CmdDescriptor) String() string { return proto.CompactTextString(m) }
func (*CmdDescriptor) ProtoMessage()    {}
func (*CmdDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce77433d29a243f3, []int{4}
}

func (m *CmdDescriptor) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CmdDescriptor.Unmarshal(m, b)
}
func (m *CmdDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CmdDescriptor.Marshal(b, m, deterministic)
}
func (m *CmdDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CmdDescriptor.Merge(m, src)
}
func (m *CmdDescriptor) XXX_Size() int {
	return xxx_messageInfo_CmdDescriptor.Size(m)
}
func (m *CmdDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_CmdDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_CmdDescriptor proto.InternalMessageInfo

func (m *CmdDescriptor) GetSelector() *Selector {
	if m != nil {
		return m.Selector
	}
	return nil
}

func (m *CmdDescriptor) GetSetup() *CmdDescriptor_Setup {
	if m != nil {
		return m.Setup
	}
	return nil
}

func (m *CmdDescriptor) GetCross() *CmdDescriptor_Cross {
	if m != nil {
		return m.Cross
	}
	return nil
}

func (m *CmdDescriptor) GetEmulationOpts() *CmdDescriptor_EmulationOpts {
	if m != nil {
		return m.EmulationOpts
	}
	return nil
}

// command binaries to run.
// it includes driver program (e.g. gcc), and subprograms
// (e.g. cc1, cc1plus, as, objcopy etc).
// note: shared objects in standard dirs (/lib, /usr/lib, etc)
// will be included in image, so no need to install in each run.
// shared objects specified by RPATH (i.e. $ORIGIN/../lib, e.g.
// libstdc++.so.6 in chromium-clang) should be specified in files below.
//
// path is represented in path type.
type CmdDescriptor_Setup struct {
	// If cmd_file.Path is abs path, then this command binary is installed
	// in image at the path, and no need to setup. when run command, use
	// this path instead of local_compiler_path.  files would be empty.
	//
	// If cmd_file.Path is relative path from cmd_dir, then this command
	// binary is installed at local_compiler_path as cmd run setup.  files
	// would be also installed.
	CmdFile              *FileSpec              `protobuf:"bytes,1,opt,name=cmd_file,json=cmdFile,proto3" json:"cmd_file,omitempty"`
	CmdDir               string                 `protobuf:"bytes,2,opt,name=cmd_dir,json=cmdDir,proto3" json:"cmd_dir,omitempty"`
	Files                []*FileSpec            `protobuf:"bytes,3,rep,name=files,proto3" json:"files,omitempty"`
	PathType             CmdDescriptor_PathType `protobuf:"varint,4,opt,name=path_type,json=pathType,proto3,enum=command.CmdDescriptor_PathType" json:"path_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *CmdDescriptor_Setup) Reset()         { *m = CmdDescriptor_Setup{} }
func (m *CmdDescriptor_Setup) String() string { return proto.CompactTextString(m) }
func (*CmdDescriptor_Setup) ProtoMessage()    {}
func (*CmdDescriptor_Setup) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce77433d29a243f3, []int{4, 0}
}

func (m *CmdDescriptor_Setup) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CmdDescriptor_Setup.Unmarshal(m, b)
}
func (m *CmdDescriptor_Setup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CmdDescriptor_Setup.Marshal(b, m, deterministic)
}
func (m *CmdDescriptor_Setup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CmdDescriptor_Setup.Merge(m, src)
}
func (m *CmdDescriptor_Setup) XXX_Size() int {
	return xxx_messageInfo_CmdDescriptor_Setup.Size(m)
}
func (m *CmdDescriptor_Setup) XXX_DiscardUnknown() {
	xxx_messageInfo_CmdDescriptor_Setup.DiscardUnknown(m)
}

var xxx_messageInfo_CmdDescriptor_Setup proto.InternalMessageInfo

func (m *CmdDescriptor_Setup) GetCmdFile() *FileSpec {
	if m != nil {
		return m.CmdFile
	}
	return nil
}

func (m *CmdDescriptor_Setup) GetCmdDir() string {
	if m != nil {
		return m.CmdDir
	}
	return ""
}

func (m *CmdDescriptor_Setup) GetFiles() []*FileSpec {
	if m != nil {
		return m.Files
	}
	return nil
}

func (m *CmdDescriptor_Setup) GetPathType() CmdDescriptor_PathType {
	if m != nil {
		return m.PathType
	}
	return CmdDescriptor_UNKNOWN_PATH_TYPE
}

// cross options (when user's platform and cmd_server's platform differs)
type CmdDescriptor_Cross struct {
	// If clang_need_target is true, exec_service adds -target <arch>
	// in args if args does not have -target option.
	// note: it is clang/clang++ specific.
	ClangNeedTarget      bool     `protobuf:"varint,1,opt,name=clang_need_target,json=clangNeedTarget,proto3" json:"clang_need_target,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CmdDescriptor_Cross) Reset()         { *m = CmdDescriptor_Cross{} }
func (m *CmdDescriptor_Cross) String() string { return proto.CompactTextString(m) }
func (*CmdDescriptor_Cross) ProtoMessage()    {}
func (*CmdDescriptor_Cross) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce77433d29a243f3, []int{4, 1}
}

func (m *CmdDescriptor_Cross) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CmdDescriptor_Cross.Unmarshal(m, b)
}
func (m *CmdDescriptor_Cross) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CmdDescriptor_Cross.Marshal(b, m, deterministic)
}
func (m *CmdDescriptor_Cross) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CmdDescriptor_Cross.Merge(m, src)
}
func (m *CmdDescriptor_Cross) XXX_Size() int {
	return xxx_messageInfo_CmdDescriptor_Cross.Size(m)
}
func (m *CmdDescriptor_Cross) XXX_DiscardUnknown() {
	xxx_messageInfo_CmdDescriptor_Cross.DiscardUnknown(m)
}

var xxx_messageInfo_CmdDescriptor_Cross proto.InternalMessageInfo

func (m *CmdDescriptor_Cross) GetClangNeedTarget() bool {
	if m != nil {
		return m.ClangNeedTarget
	}
	return false
}

// EmulationOpts is used when goma backend cannot fully emulate client environment.
type CmdDescriptor_EmulationOpts struct {
	// respect_client_include_paths is true if we need to append
	// include directories sent from goma client to command line.
	// For example, when we choose a binary is not relocatable, we need to
	// specify -isystem, -imsvc (or equivalent)
	RespectClientIncludePaths bool     `protobuf:"varint,1,opt,name=respect_client_include_paths,json=respectClientIncludePaths,proto3" json:"respect_client_include_paths,omitempty"`
	XXX_NoUnkeyedLiteral      struct{} `json:"-"`
	XXX_unrecognized          []byte   `json:"-"`
	XXX_sizecache             int32    `json:"-"`
}

func (m *CmdDescriptor_EmulationOpts) Reset()         { *m = CmdDescriptor_EmulationOpts{} }
func (m *CmdDescriptor_EmulationOpts) String() string { return proto.CompactTextString(m) }
func (*CmdDescriptor_EmulationOpts) ProtoMessage()    {}
func (*CmdDescriptor_EmulationOpts) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce77433d29a243f3, []int{4, 2}
}

func (m *CmdDescriptor_EmulationOpts) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CmdDescriptor_EmulationOpts.Unmarshal(m, b)
}
func (m *CmdDescriptor_EmulationOpts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CmdDescriptor_EmulationOpts.Marshal(b, m, deterministic)
}
func (m *CmdDescriptor_EmulationOpts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CmdDescriptor_EmulationOpts.Merge(m, src)
}
func (m *CmdDescriptor_EmulationOpts) XXX_Size() int {
	return xxx_messageInfo_CmdDescriptor_EmulationOpts.Size(m)
}
func (m *CmdDescriptor_EmulationOpts) XXX_DiscardUnknown() {
	xxx_messageInfo_CmdDescriptor_EmulationOpts.DiscardUnknown(m)
}

var xxx_messageInfo_CmdDescriptor_EmulationOpts proto.InternalMessageInfo

func (m *CmdDescriptor_EmulationOpts) GetRespectClientIncludePaths() bool {
	if m != nil {
		return m.RespectClientIncludePaths
	}
	return false
}

// RemoteexecPlatform is a set of requirements, such as hardware,
// operating system, for an remoteexec API.
type RemoteexecPlatform struct {
	Properties []*RemoteexecPlatform_Property `protobuf:"bytes,1,rep,name=properties,proto3" json:"properties,omitempty"`
	// Basename of RBE instance to use. e.g. "default_instance" or "windows".
	RbeInstanceBasename string `protobuf:"bytes,2,opt,name=rbe_instance_basename,json=rbeInstanceBasename,proto3" json:"rbe_instance_basename,omitempty"`
	// Set true if nsjail is available in the platform image.
	// TODO: deprecated. always requires najail on linux platform.
	HasNsjail            bool     `protobuf:"varint,3,opt,name=has_nsjail,json=hasNsjail,proto3" json:"has_nsjail,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoteexecPlatform) Reset()         { *m = RemoteexecPlatform{} }
func (m *RemoteexecPlatform) String() string { return proto.CompactTextString(m) }
func (*RemoteexecPlatform) ProtoMessage()    {}
func (*RemoteexecPlatform) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce77433d29a243f3, []int{5}
}

func (m *RemoteexecPlatform) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemoteexecPlatform.Unmarshal(m, b)
}
func (m *RemoteexecPlatform) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemoteexecPlatform.Marshal(b, m, deterministic)
}
func (m *RemoteexecPlatform) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteexecPlatform.Merge(m, src)
}
func (m *RemoteexecPlatform) XXX_Size() int {
	return xxx_messageInfo_RemoteexecPlatform.Size(m)
}
func (m *RemoteexecPlatform) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteexecPlatform.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteexecPlatform proto.InternalMessageInfo

func (m *RemoteexecPlatform) GetProperties() []*RemoteexecPlatform_Property {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *RemoteexecPlatform) GetRbeInstanceBasename() string {
	if m != nil {
		return m.RbeInstanceBasename
	}
	return ""
}

func (m *RemoteexecPlatform) GetHasNsjail() bool {
	if m != nil {
		return m.HasNsjail
	}
	return false
}

type RemoteexecPlatform_Property struct {
	// The property name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The property value.
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoteexecPlatform_Property) Reset()         { *m = RemoteexecPlatform_Property{} }
func (m *RemoteexecPlatform_Property) String() string { return proto.CompactTextString(m) }
func (*RemoteexecPlatform_Property) ProtoMessage()    {}
func (*RemoteexecPlatform_Property) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce77433d29a243f3, []int{5, 0}
}

func (m *RemoteexecPlatform_Property) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemoteexecPlatform_Property.Unmarshal(m, b)
}
func (m *RemoteexecPlatform_Property) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemoteexecPlatform_Property.Marshal(b, m, deterministic)
}
func (m *RemoteexecPlatform_Property) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteexecPlatform_Property.Merge(m, src)
}
func (m *RemoteexecPlatform_Property) XXX_Size() int {
	return xxx_messageInfo_RemoteexecPlatform_Property.Size(m)
}
func (m *RemoteexecPlatform_Property) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteexecPlatform_Property.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteexecPlatform_Property proto.InternalMessageInfo

func (m *RemoteexecPlatform_Property) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RemoteexecPlatform_Property) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Config is a command config; mapping from selector.
type Config struct {
	Target             *Target             `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	BuildInfo          *BuildInfo          `protobuf:"bytes,3,opt,name=build_info,json=buildInfo,proto3" json:"build_info,omitempty"`
	CmdDescriptor      *CmdDescriptor      `protobuf:"bytes,4,opt,name=cmd_descriptor,json=cmdDescriptor,proto3" json:"cmd_descriptor,omitempty"`
	RemoteexecPlatform *RemoteexecPlatform `protobuf:"bytes,5,opt,name=remoteexec_platform,json=remoteexecPlatform,proto3" json:"remoteexec_platform,omitempty"`
	// If this config is configured for arbitrary toolchain support,
	// set dimensions of the config. Otherwise, this should be nil.
	Dimensions           []string `protobuf:"bytes,6,rep,name=dimensions,proto3" json:"dimensions,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Config) Reset()         { *m = Config{} }
func (m *Config) String() string { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()    {}
func (*Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce77433d29a243f3, []int{6}
}

func (m *Config) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Config.Unmarshal(m, b)
}
func (m *Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Config.Marshal(b, m, deterministic)
}
func (m *Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Config.Merge(m, src)
}
func (m *Config) XXX_Size() int {
	return xxx_messageInfo_Config.Size(m)
}
func (m *Config) XXX_DiscardUnknown() {
	xxx_messageInfo_Config.DiscardUnknown(m)
}

var xxx_messageInfo_Config proto.InternalMessageInfo

func (m *Config) GetTarget() *Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *Config) GetBuildInfo() *BuildInfo {
	if m != nil {
		return m.BuildInfo
	}
	return nil
}

func (m *Config) GetCmdDescriptor() *CmdDescriptor {
	if m != nil {
		return m.CmdDescriptor
	}
	return nil
}

func (m *Config) GetRemoteexecPlatform() *RemoteexecPlatform {
	if m != nil {
		return m.RemoteexecPlatform
	}
	return nil
}

func (m *Config) GetDimensions() []string {
	if m != nil {
		return m.Dimensions
	}
	return nil
}

// Platform is a set of requirements, such as haredware, operting system
// for RBE backend.
// matched with build.bazel.remote.execution.v2.Platform.
type Platform struct {
	Properties           []*Platform_Property `protobuf:"bytes,1,rep,name=properties,proto3" json:"properties,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Platform) Reset()         { *m = Platform{} }
func (m *Platform) String() string { return proto.CompactTextString(m) }
func (*Platform) ProtoMessage()    {}
func (*Platform) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce77433d29a243f3, []int{7}
}

func (m *Platform) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Platform.Unmarshal(m, b)
}
func (m *Platform) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Platform.Marshal(b, m, deterministic)
}
func (m *Platform) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Platform.Merge(m, src)
}
func (m *Platform) XXX_Size() int {
	return xxx_messageInfo_Platform.Size(m)
}
func (m *Platform) XXX_DiscardUnknown() {
	xxx_messageInfo_Platform.DiscardUnknown(m)
}

var xxx_messageInfo_Platform proto.InternalMessageInfo

func (m *Platform) GetProperties() []*Platform_Property {
	if m != nil {
		return m.Properties
	}
	return nil
}

type Platform_Property struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Platform_Property) Reset()         { *m = Platform_Property{} }
func (m *Platform_Property) String() string { return proto.CompactTextString(m) }
func (*Platform_Property) ProtoMessage()    {}
func (*Platform_Property) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce77433d29a243f3, []int{7, 0}
}

func (m *Platform_Property) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Platform_Property.Unmarshal(m, b)
}
func (m *Platform_Property) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Platform_Property.Marshal(b, m, deterministic)
}
func (m *Platform_Property) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Platform_Property.Merge(m, src)
}
func (m *Platform_Property) XXX_Size() int {
	return xxx_messageInfo_Platform_Property.Size(m)
}
func (m *Platform_Property) XXX_DiscardUnknown() {
	xxx_messageInfo_Platform_Property.DiscardUnknown(m)
}

var xxx_messageInfo_Platform_Property proto.InternalMessageInfo

func (m *Platform_Property) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Platform_Property) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// RuntimeConfig is config for runtime.
// NEXT ID TO USE: 9
type RuntimeConfig struct {
	// name of runtime.
	//
	// if this runtime config found in a bucket,
	// the following files will be detected in this name directory in the bucket:
	//   seq
	//   <prebuilt-item>/descriptors/<descriptorHash>
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// service address for the runtime. i.e. RBE address.
	ServiceAddr string `protobuf:"bytes,2,opt,name=service_addr,json=serviceAddr,proto3" json:"service_addr,omitempty"`
	// If not nil, this runtime config will be also configured
	// for arbitrary toolchain support.
	// This is selector to use this runtime. i.e. if client request contains
	// the dimentions, this runtime config will be selected.
	PlatformRuntimeConfig *PlatformRuntimeConfig `protobuf:"bytes,6,opt,name=platform_runtime_config,json=platformRuntimeConfig,proto3" json:"platform_runtime_config,omitempty"`
	// Platform is a set of requirements, such as hardware, operating system
	// for RBE backend.
	Platform *Platform `protobuf:"bytes,8,opt,name=platform,proto3" json:"platform,omitempty"`
	// prebuilts prefix to allow.
	// if allowed_prebuilts specified, only prebuilts that are matched
	// by allowed_prebuilts is allowed. other prebuilts are disallowed.
	// if no allowed_prebuilts specified, any prebuilts are allowed
	// if it is not disallowed by disallowed_prebuilts.
	AllowedPrebuilts []string `protobuf:"bytes,3,rep,name=allowed_prebuilts,json=allowedPrebuilts,proto3" json:"allowed_prebuilts,omitempty"`
	// prebuilts prefix to disallow.
	// if no disallowed_prebuilts specified, only allowed_prebuilts is used.
	// if both are not specified, all prebuilts are allowed.
	DisallowedPrebuilts []string `protobuf:"bytes,4,rep,name=disallowed_prebuilts,json=disallowedPrebuilts,proto3" json:"disallowed_prebuilts,omitempty"`
	// commands that is disallowed in the runtime.
	// selector field is used for exact match, if it is specified.
	// selector field that is not specified in disallowed_commands will
	// match any selector.
	DisallowedCommands   []*Selector `protobuf:"bytes,5,rep,name=disallowed_commands,json=disallowedCommands,proto3" json:"disallowed_commands,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *RuntimeConfig) Reset()         { *m = RuntimeConfig{} }
func (m *RuntimeConfig) String() string { return proto.CompactTextString(m) }
func (*RuntimeConfig) ProtoMessage()    {}
func (*RuntimeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce77433d29a243f3, []int{8}
}

func (m *RuntimeConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RuntimeConfig.Unmarshal(m, b)
}
func (m *RuntimeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RuntimeConfig.Marshal(b, m, deterministic)
}
func (m *RuntimeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuntimeConfig.Merge(m, src)
}
func (m *RuntimeConfig) XXX_Size() int {
	return xxx_messageInfo_RuntimeConfig.Size(m)
}
func (m *RuntimeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RuntimeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RuntimeConfig proto.InternalMessageInfo

func (m *RuntimeConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RuntimeConfig) GetServiceAddr() string {
	if m != nil {
		return m.ServiceAddr
	}
	return ""
}

func (m *RuntimeConfig) GetPlatformRuntimeConfig() *PlatformRuntimeConfig {
	if m != nil {
		return m.PlatformRuntimeConfig
	}
	return nil
}

func (m *RuntimeConfig) GetPlatform() *Platform {
	if m != nil {
		return m.Platform
	}
	return nil
}

func (m *RuntimeConfig) GetAllowedPrebuilts() []string {
	if m != nil {
		return m.AllowedPrebuilts
	}
	return nil
}

func (m *RuntimeConfig) GetDisallowedPrebuilts() []string {
	if m != nil {
		return m.DisallowedPrebuilts
	}
	return nil
}

func (m *RuntimeConfig) GetDisallowedCommands() []*Selector {
	if m != nil {
		return m.DisallowedCommands
	}
	return nil
}

// PlatformRuntimeConfig is a config to use the runtime.
// NEXT ID TO USE: 3
type PlatformRuntimeConfig struct {
	Dimensions []string `protobuf:"bytes,1,rep,name=dimensions,proto3" json:"dimensions,omitempty"`
	// Set true if nsjail is available in the platform image.
	HasNsjail            bool     `protobuf:"varint,2,opt,name=has_nsjail,json=hasNsjail,proto3" json:"has_nsjail,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlatformRuntimeConfig) Reset()         { *m = PlatformRuntimeConfig{} }
func (m *PlatformRuntimeConfig) String() string { return proto.CompactTextString(m) }
func (*PlatformRuntimeConfig) ProtoMessage()    {}
func (*PlatformRuntimeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce77433d29a243f3, []int{9}
}

func (m *PlatformRuntimeConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlatformRuntimeConfig.Unmarshal(m, b)
}
func (m *PlatformRuntimeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlatformRuntimeConfig.Marshal(b, m, deterministic)
}
func (m *PlatformRuntimeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlatformRuntimeConfig.Merge(m, src)
}
func (m *PlatformRuntimeConfig) XXX_Size() int {
	return xxx_messageInfo_PlatformRuntimeConfig.Size(m)
}
func (m *PlatformRuntimeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PlatformRuntimeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PlatformRuntimeConfig proto.InternalMessageInfo

func (m *PlatformRuntimeConfig) GetDimensions() []string {
	if m != nil {
		return m.Dimensions
	}
	return nil
}

func (m *PlatformRuntimeConfig) GetHasNsjail() bool {
	if m != nil {
		return m.HasNsjail
	}
	return false
}

// ConfigMap is a config map; data source of Config.
// admin creates/updates the file in <bucket>/<config>.config
// and ConfigMapBucket will read the info.
type ConfigMap struct {
	Runtimes             []*RuntimeConfig `protobuf:"bytes,1,rep,name=runtimes,proto3" json:"runtimes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ConfigMap) Reset()         { *m = ConfigMap{} }
func (m *ConfigMap) String() string { return proto.CompactTextString(m) }
func (*ConfigMap) ProtoMessage()    {}
func (*ConfigMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce77433d29a243f3, []int{10}
}

func (m *ConfigMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigMap.Unmarshal(m, b)
}
func (m *ConfigMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigMap.Marshal(b, m, deterministic)
}
func (m *ConfigMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigMap.Merge(m, src)
}
func (m *ConfigMap) XXX_Size() int {
	return xxx_messageInfo_ConfigMap.Size(m)
}
func (m *ConfigMap) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigMap.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigMap proto.InternalMessageInfo

func (m *ConfigMap) GetRuntimes() []*RuntimeConfig {
	if m != nil {
		return m.Runtimes
	}
	return nil
}

// TODO: remove ConfigResp.
type ConfigResp struct {
	VersionId            string    `protobuf:"bytes,2,opt,name=version_id,json=versionId,proto3" json:"version_id,omitempty"`
	Configs              []*Config `protobuf:"bytes,1,rep,name=configs,proto3" json:"configs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ConfigResp) Reset()         { *m = ConfigResp{} }
func (m *ConfigResp) String() string { return proto.CompactTextString(m) }
func (*ConfigResp) ProtoMessage()    {}
func (*ConfigResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce77433d29a243f3, []int{11}
}

func (m *ConfigResp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigResp.Unmarshal(m, b)
}
func (m *ConfigResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigResp.Marshal(b, m, deterministic)
}
func (m *ConfigResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigResp.Merge(m, src)
}
func (m *ConfigResp) XXX_Size() int {
	return xxx_messageInfo_ConfigResp.Size(m)
}
func (m *ConfigResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigResp.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigResp proto.InternalMessageInfo

func (m *ConfigResp) GetVersionId() string {
	if m != nil {
		return m.VersionId
	}
	return ""
}

func (m *ConfigResp) GetConfigs() []*Config {
	if m != nil {
		return m.Configs
	}
	return nil
}

func init() {
	proto.RegisterEnum("command.CmdDescriptor_PathType", CmdDescriptor_PathType_name, CmdDescriptor_PathType_value)
	proto.RegisterType((*Selector)(nil), "command.Selector")
	proto.RegisterType((*FileSpec)(nil), "command.FileSpec")
	proto.RegisterType((*Target)(nil), "command.Target")
	proto.RegisterType((*BuildInfo)(nil), "command.BuildInfo")
	proto.RegisterType((*CmdDescriptor)(nil), "command.CmdDescriptor")
	proto.RegisterType((*CmdDescriptor_Setup)(nil), "command.CmdDescriptor.Setup")
	proto.RegisterType((*CmdDescriptor_Cross)(nil), "command.CmdDescriptor.Cross")
	proto.RegisterType((*CmdDescriptor_EmulationOpts)(nil), "command.CmdDescriptor.EmulationOpts")
	proto.RegisterType((*RemoteexecPlatform)(nil), "command.RemoteexecPlatform")
	proto.RegisterType((*RemoteexecPlatform_Property)(nil), "command.RemoteexecPlatform.Property")
	proto.RegisterType((*Config)(nil), "command.Config")
	proto.RegisterType((*Platform)(nil), "command.Platform")
	proto.RegisterType((*Platform_Property)(nil), "command.Platform.Property")
	proto.RegisterType((*RuntimeConfig)(nil), "command.RuntimeConfig")
	proto.RegisterType((*PlatformRuntimeConfig)(nil), "command.PlatformRuntimeConfig")
	proto.RegisterType((*ConfigMap)(nil), "command.ConfigMap")
	proto.RegisterType((*ConfigResp)(nil), "command.ConfigResp")
}

func init() { proto.RegisterFile("command/command.proto", fileDescriptor_ce77433d29a243f3) }

var fileDescriptor_ce77433d29a243f3 = []byte{
	// 1215 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xdb, 0x72, 0x1b, 0x45,
	0x13, 0xfe, 0x65, 0xeb, 0xb0, 0xdb, 0x8a, 0x13, 0x79, 0x1c, 0x27, 0x8a, 0x7e, 0x93, 0x04, 0x41,
	0x55, 0x02, 0x01, 0xb9, 0xa2, 0x70, 0x01, 0x14, 0x54, 0x2a, 0xb6, 0x43, 0xc5, 0x0e, 0xd8, 0xaa,
	0xb1, 0x49, 0xe0, 0x6a, 0x6a, 0xb4, 0xdb, 0x96, 0x86, 0xec, 0x89, 0x99, 0x91, 0x41, 0x14, 0xcf,
	0x40, 0xf1, 0x04, 0xbc, 0x05, 0x4f, 0xc2, 0x23, 0xf0, 0x0c, 0xdc, 0x53, 0x73, 0xd8, 0x55, 0x6c,
	0x2b, 0xb9, 0xe0, 0x4a, 0xd3, 0xdd, 0xdf, 0x74, 0x4f, 0x77, 0x7f, 0xdd, 0x2b, 0xd8, 0x8c, 0xf2,
	0x34, 0xe5, 0x59, 0xbc, 0xed, 0x7f, 0x07, 0x85, 0xcc, 0x75, 0x4e, 0x5a, 0x5e, 0xec, 0x6d, 0xf0,
	0x42, 0x6c, 0x4f, 0xf2, 0x94, 0xb3, 0x98, 0x6b, 0xee, 0xac, 0xbd, 0x3b, 0x93, 0x3c, 0x9f, 0x24,
	0xb8, 0x6d, 0xa5, 0xf1, 0xec, 0x74, 0x5b, 0x8b, 0x14, 0x95, 0xe6, 0x69, 0xe1, 0x00, 0xfd, 0x1f,
	0x21, 0x38, 0xc6, 0x04, 0x23, 0x9d, 0x4b, 0x42, 0xa0, 0x9e, 0xf1, 0x14, 0xbb, 0xb5, 0xbb, 0xb5,
	0xfb, 0x21, 0xb5, 0x67, 0xd2, 0x85, 0xd6, 0x19, 0x4a, 0x25, 0xf2, 0xac, 0xbb, 0x62, 0xd5, 0xa5,
	0x48, 0x6e, 0x40, 0x53, 0x73, 0x39, 0x41, 0xdd, 0x5d, 0xb5, 0x06, 0x2f, 0x91, 0x3b, 0xd0, 0x1e,
	0x8b, 0x8c, 0xcb, 0x39, 0x9b, 0x72, 0x35, 0xed, 0xd6, 0xad, 0x11, 0x9c, 0xea, 0x19, 0x57, 0xd3,
	0xfe, 0x5f, 0x35, 0x08, 0xbe, 0x12, 0x09, 0x1e, 0x17, 0x18, 0x99, 0x98, 0x05, 0xd7, 0xd3, 0x32,
	0xa6, 0x39, 0x1b, 0x9d, 0x12, 0xbf, 0xa0, 0x0d, 0xb8, 0x4a, 0xed, 0xd9, 0xe8, 0xac, 0x3b, 0x17,
	0xcb, 0x9e, 0xc9, 0x7b, 0xb0, 0x26, 0x14, 0xc3, 0x9f, 0x31, 0x9a, 0x69, 0x3e, 0x4e, 0xd0, 0xc6,
	0x0a, 0xe8, 0x15, 0xa1, 0x9e, 0x56, 0x3a, 0x93, 0x80, 0x9a, 0xa7, 0x89, 0xc8, 0x5e, 0x75, 0x1b,
	0x2e, 0x01, 0x2f, 0x92, 0x5b, 0x10, 0x18, 0x37, 0xec, 0x15, 0xce, 0xbb, 0x4d, 0x67, 0x32, 0xf2,
	0x73, 0x9c, 0x93, 0x07, 0x50, 0x1f, 0x27, 0xf9, 0xb8, 0xdb, 0xba, 0x5b, 0xbb, 0xdf, 0x1e, 0xde,
	0x1c, 0xc4, 0x78, 0xa6, 0xf3, 0x3c, 0x51, 0xcc, 0xd4, 0x77, 0x60, 0x1e, 0xbf, 0x93, 0xe4, 0x63,
	0x6a, 0x41, 0x07, 0xf5, 0x20, 0xe8, 0x84, 0xfd, 0x2d, 0x68, 0x9e, 0xb8, 0x02, 0x10, 0xa8, 0xf3,
	0x38, 0x96, 0x65, 0x4a, 0xe6, 0xdc, 0xff, 0xa7, 0x06, 0xe1, 0xce, 0x4c, 0x24, 0xf1, 0x7e, 0x76,
	0x9a, 0x9b, 0x37, 0x45, 0x12, 0xb9, 0xce, 0x65, 0x59, 0x54, 0x2f, 0x92, 0x1e, 0x04, 0xd3, 0x5c,
	0x69, 0xdb, 0x06, 0x97, 0x6a, 0x25, 0x93, 0x2d, 0x08, 0x63, 0x21, 0x6d, 0xab, 0xe6, 0xbe, 0xac,
	0x0b, 0x05, 0xf9, 0x14, 0xc2, 0xaa, 0xb7, 0x36, 0xd3, 0xf6, 0xb0, 0x37, 0x70, 0xdd, 0x1f, 0x94,
	0xdd, 0x1f, 0x9c, 0x94, 0x08, 0xba, 0x00, 0x93, 0x77, 0x00, 0xa2, 0x34, 0x66, 0x0a, 0xe5, 0x19,
	0x4a, 0x9b, 0x72, 0x48, 0xc3, 0x28, 0x8d, 0x8f, 0xad, 0xc2, 0x84, 0x35, 0xb9, 0x47, 0x53, 0x2e,
	0xb2, 0x6e, 0xe0, 0xac, 0x95, 0xe2, 0xa0, 0x1e, 0xd4, 0x3a, 0x2b, 0x07, 0xf5, 0xa0, 0xd9, 0x69,
	0xd1, 0xa6, 0xa1, 0xa2, 0xd0, 0x34, 0x9c, 0x15, 0x4a, 0x4b, 0xe4, 0xa9, 0xea, 0xff, 0xde, 0x80,
	0xb5, 0xdd, 0x34, 0xde, 0x43, 0x15, 0x49, 0x51, 0x98, 0x0c, 0x3f, 0x86, 0x40, 0x79, 0xc2, 0xd9,
	0x0a, 0xb5, 0x87, 0xeb, 0x83, 0x92, 0xd1, 0x25, 0x13, 0x69, 0x05, 0x21, 0x43, 0x68, 0x28, 0xd4,
	0xb3, 0xc2, 0x16, 0xaa, 0x3d, 0xdc, 0xaa, 0xb0, 0xe7, 0xbc, 0x0e, 0x8e, 0x0d, 0x86, 0x3a, 0xa8,
	0xb9, 0x13, 0xc9, 0x5c, 0x29, 0x5b, 0xc1, 0x37, 0xdf, 0xd9, 0x35, 0x18, 0xea, 0xa0, 0xe4, 0x39,
	0x5c, 0xc5, 0x74, 0x96, 0x70, 0x2d, 0xf2, 0x8c, 0xe5, 0x85, 0x56, 0x96, 0x12, 0xed, 0xe1, 0xfb,
	0x6f, 0xb8, 0xfc, 0xb4, 0x04, 0x1f, 0x15, 0x5a, 0xd1, 0x35, 0x7c, 0x5d, 0xec, 0xfd, 0x59, 0x83,
	0x86, 0x7d, 0x11, 0xf9, 0x08, 0x02, 0x53, 0xdb, 0x53, 0x91, 0xe0, 0xa5, 0x6c, 0xcb, 0x19, 0xa0,
	0xad, 0x28, 0x8d, 0x8d, 0x40, 0x6e, 0x82, 0x39, 0xb2, 0x58, 0x94, 0xbc, 0x68, 0x46, 0x69, 0xbc,
	0x27, 0x24, 0xb9, 0x07, 0x0d, 0xe3, 0xc2, 0x64, 0xb4, 0xba, 0xdc, 0x87, 0xb3, 0x93, 0x2f, 0x20,
	0x34, 0x23, 0xc4, 0xf4, 0xbc, 0x70, 0xe3, 0x70, 0x75, 0x78, 0xe7, 0x0d, 0x19, 0x8c, 0xb8, 0x9e,
	0x9e, 0xcc, 0x0b, 0xa4, 0x41, 0xe1, 0x4f, 0xbd, 0x47, 0xd0, 0xb0, 0x45, 0x21, 0x1f, 0xc2, 0x7a,
	0x94, 0xf0, 0x6c, 0xc2, 0x32, 0xc4, 0x98, 0xf9, 0x31, 0xaf, 0xd9, 0xe9, 0xba, 0x66, 0x0d, 0x87,
	0x88, 0xb1, 0xa3, 0x7b, 0x6f, 0x04, 0x6b, 0xe7, 0x8a, 0x41, 0x1e, 0xc3, 0x96, 0x44, 0x55, 0x60,
	0xa4, 0x59, 0x94, 0x08, 0xcc, 0x34, 0x13, 0x59, 0x94, 0xcc, 0x62, 0x64, 0x26, 0x90, 0xf2, 0x7e,
	0x6e, 0x79, 0xcc, 0xae, 0x85, 0xec, 0x3b, 0x84, 0x79, 0x93, 0xea, 0x7f, 0x06, 0x41, 0xf9, 0x38,
	0xb2, 0x09, 0xeb, 0xdf, 0x1e, 0x3e, 0x3f, 0x3c, 0x7a, 0x79, 0xc8, 0x46, 0x4f, 0x4e, 0x9e, 0xb1,
	0x93, 0xef, 0x47, 0x4f, 0x3b, 0xff, 0x23, 0x21, 0x34, 0x46, 0x47, 0xc7, 0xfb, 0xdf, 0x75, 0x6a,
	0xa4, 0x0d, 0xad, 0x97, 0xfb, 0x87, 0x7b, 0x47, 0x2f, 0x8f, 0x2d, 0x11, 0xeb, 0x9d, 0xc6, 0x41,
	0x3d, 0x68, 0x74, 0x9a, 0xd4, 0x56, 0xde, 0xb4, 0x92, 0xb6, 0x0b, 0x1e, 0xbd, 0xe2, 0x13, 0x34,
	0x52, 0xff, 0xef, 0x1a, 0x10, 0x8a, 0x69, 0xae, 0xd1, 0x6c, 0x8e, 0x51, 0xc2, 0xf5, 0x69, 0x2e,
	0x53, 0xb2, 0x07, 0x50, 0xc8, 0xbc, 0x40, 0xa9, 0x05, 0x9a, 0x37, 0xae, 0x9e, 0x6b, 0xfe, 0xe5,
	0x0b, 0x83, 0x91, 0x43, 0xcf, 0xe9, 0x6b, 0xf7, 0xc8, 0x10, 0x36, 0xe5, 0x18, 0x99, 0xc8, 0x94,
	0xe6, 0x59, 0x84, 0x6c, 0xcc, 0x15, 0xda, 0x61, 0x76, 0xfd, 0xdc, 0x90, 0x63, 0xdc, 0xf7, 0xb6,
	0x1d, 0x6f, 0x32, 0xf3, 0x37, 0xe5, 0x8a, 0x65, 0xea, 0x07, 0x2e, 0x12, 0xcb, 0xd9, 0x80, 0x86,
	0x53, 0xae, 0x0e, 0xad, 0xa2, 0xf7, 0x09, 0x04, 0x65, 0xa8, 0xa5, 0x1b, 0xfa, 0x3a, 0x34, 0xce,
	0x78, 0x32, 0x2b, 0x43, 0x38, 0xa1, 0xff, 0xc7, 0x0a, 0x34, 0x77, 0xf3, 0xec, 0x54, 0x4c, 0xc8,
	0xbd, 0x6a, 0x51, 0x3b, 0x06, 0x5e, 0xab, 0xb2, 0x72, 0x1d, 0xac, 0x36, 0xf7, 0x43, 0x80, 0xb1,
	0xd9, 0x51, 0x4c, 0x64, 0xa7, 0xb9, 0x1f, 0x1e, 0x52, 0x81, 0xab, 0xf5, 0x45, 0xc3, 0x71, 0xb5,
	0xc9, 0xbe, 0x84, 0xab, 0x96, 0xb1, 0x15, 0xad, 0x2c, 0xe9, 0xda, 0xc3, 0x1b, 0xcb, 0x49, 0x47,
	0xd7, 0xa2, 0x73, 0xcb, 0xe0, 0x6b, 0xd8, 0x90, 0x55, 0x65, 0x59, 0xe1, 0x4b, 0xeb, 0xd7, 0xd7,
	0xff, 0xdf, 0x52, 0x7d, 0x4a, 0xe4, 0xe5, 0x16, 0xde, 0x06, 0x88, 0x45, 0x8a, 0x99, 0xf9, 0x3c,
	0x99, 0xf9, 0x5d, 0x35, 0x1f, 0x9e, 0x85, 0xe6, 0xa0, 0x1e, 0xac, 0x74, 0x56, 0x69, 0x43, 0xa4,
	0x7c, 0x82, 0xfd, 0x5f, 0x21, 0xa8, 0x2e, 0x7e, 0xbe, 0xa4, 0xf7, 0xbd, 0x2a, 0xfa, 0x5b, 0x3b,
	0xfe, 0x1f, 0xdb, 0xf3, 0xdb, 0x2a, 0xac, 0xd1, 0x59, 0x66, 0x96, 0xb0, 0xef, 0xd2, 0xb2, 0xbb,
	0xef, 0xc2, 0x15, 0xb3, 0x95, 0x45, 0x84, 0xcc, 0x7e, 0x51, 0x9c, 0x8b, 0xb6, 0xd7, 0x3d, 0x89,
	0x63, 0x49, 0x5e, 0xc0, 0xcd, 0xb2, 0x6c, 0x4c, 0x3a, 0x87, 0x2c, 0xb2, 0x1e, 0xfd, 0x02, 0xbb,
	0x7d, 0x29, 0x8f, 0x73, 0x71, 0xe9, 0x66, 0xb1, 0x4c, 0x6d, 0xd6, 0x74, 0xd5, 0x8e, 0xe0, 0xc2,
	0xe2, 0xaa, 0x1c, 0x55, 0x10, 0xf2, 0x00, 0xd6, 0x79, 0x92, 0xe4, 0x3f, 0x61, 0xcc, 0x0a, 0x89,
	0x86, 0x1f, 0xda, 0x2d, 0xab, 0x90, 0x76, 0xbc, 0x61, 0x54, 0xea, 0xc9, 0x43, 0xb8, 0x1e, 0x0b,
	0x75, 0x19, 0x5f, 0xb7, 0xf8, 0x8d, 0x85, 0x6d, 0x71, 0x65, 0x07, 0x5e, 0x53, 0x33, 0xff, 0x10,
	0xd5, 0x6d, 0x5c, 0x58, 0x87, 0xd5, 0x07, 0x84, 0x2c, 0xd0, 0xbb, 0x1e, 0x7c, 0x50, 0x0f, 0x5a,
	0x9d, 0x80, 0x2e, 0x9f, 0xcf, 0xfe, 0x0b, 0xd8, 0x5c, 0x5a, 0x9f, 0x0b, 0xa4, 0xaa, 0x5d, 0x24,
	0xd5, 0x85, 0xe9, 0x5d, 0xb9, 0x30, 0xbd, 0xfd, 0xc7, 0x10, 0x3a, 0x47, 0xdf, 0x70, 0xf3, 0x61,
	0x0a, 0x7c, 0x8f, 0x4a, 0x96, 0x2d, 0xe6, 0xe4, 0x7c, 0x57, 0x2a, 0x5c, 0xff, 0x05, 0x80, 0xd7,
	0xa1, 0xb2, 0xdf, 0x6a, 0xff, 0xff, 0x8b, 0x89, 0xd8, 0xf3, 0x21, 0xf4, 0x9a, 0xfd, 0x98, 0x7c,
	0x00, 0x2d, 0xd7, 0xfc, 0xd2, 0xff, 0x62, 0xd6, 0xbd, 0x93, 0xd2, 0x3e, 0x6e, 0xda, 0x3f, 0x05,
	0x8f, 0xfe, 0x0d, 0x00, 0x00, 0xff, 0xff, 0xf5, 0x5d, 0x17, 0x06, 0x57, 0x0a, 0x00, 0x00,
}
